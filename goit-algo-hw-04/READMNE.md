# Аналіз алгоритмів сортування

## Результати тестування

### Емпіричні дані (випадкові масиви):

| Розмір | Insertion Sort | Merge Sort | Timsort | Timsort швидший за Merge у |
|--------|---------------|------------|---------|---------------------------|
| 100    | 0.000196 с    | 0.000105 с | 0.000003 с | **35x** |
| 1,000  | 0.018033 с    | 0.001473 с | 0.000041 с | **36x** |
| 5,000  | 0.444785 с    | 0.008396 с | 0.000387 с | **22x** |
| 10,000 | N/A*          | 0.018014 с | 0.000848 с | **21x** |

*Insertion Sort занадто повільний для великих масивів

### Часова складність (теоретична):
- **Insertion Sort**: O(n²)
- **Merge Sort**: O(n log n)
- **Timsort**: O(n log n) найгірший, O(n) кращий випадок

## Висновки

### 1. Insertion Sort
- Ефективний **лише** для дуже малих масивів (<100 елементів)
- На 5,000 елементів вже в **53 рази повільніший** за merge sort
- Квадратична складність робить його непрактичним для реальних задач

### 2. Merge Sort vs Timsort
**Ключове спостереження**: Timsort швидший за чистий merge sort у **20-35 разів**!

**Причини переваги Timsort:**

1. **Гібридна стратегія**:
   - Використовує insertion sort для малих підмасивів (<64 елементи)
   - Insertion sort швидший на малих фрагментах через низькі overhead витрати

2. **Галопуючий режим (galloping mode)**:
   - Оптимізація для частково відсортованих даних
   - На реальних даних часто зустрічаються впорядковані послідовності

3. **Реалізація на C**:
   - Вбудована функція `sorted()` компільована
   - Наша Python реалізація merge sort інтерпретується

4. **Оптимізація пам'яті**:
   - Timsort мінімізує копіювання даних
   - Наша реалізація створює багато тимчасових списків

### 3. Практичні рекомендації

✅ **ЗАВЖДИ використовуйте** `sorted()` або `.sort()`:
- Швидші у **20-35 разів** за власні реалізації
- Протестовані та оптимізовані
- Стабільні (зберігають порядок рівних елементів)

❌ **НЕ пишіть власні** алгоритми сортування для production, окрім випадків:
- Навчальні цілі
- Специфічні структури даних
- Кастомні критерії порівняння (але навіть тоді краще `key=` параметр)

### 4. Емпіричне підтвердження теорії

**Insertion Sort** (O(n²)):
- 100→1,000 елементів: час ↑ у **92 рази** (очікувано ~100x для n²)
- 1,000→5,000 елементів: час ↑ у **25 разів** (очікувано ~25x)
✅ Підтверджує квадратичну складність

**Merge Sort** (O(n log n)):
- 100→1,000 елементів: час ↑ у **14 разів** (теор. ~10x)
- 1,000→10,000 елементів: час ↑ у **12 разів** (теор. ~10x)
✅ Підтверджує логарифмічну складність

**Timsort** (O(n log n)):
- Демонструє аналогічне зростання до merge sort
- Але з константою у **20-35 разів меншою** завдяки оптимізаціям

## Загальний висновок

Перевага вбудованих алгоритмів Python не просто теоретична - емпіричні дані показують **драматичну різницю у 20-35 разів**. Це пояснює, чому професійні розробники використовують стандартну бібліотеку замість власних реалізацій.

Timsort - це приклад того, як теоретичні знання про алгоритми (O(n log n)) поєднуються з практичними оптимізаціями (гібридність, адаптивність, низькорівнева реалізація) для досягнення виняткової продуктивності на реальних даних.
